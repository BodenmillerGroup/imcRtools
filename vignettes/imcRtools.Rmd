---
title: "Tools for IMC data analysis"
date: "`r BiocStyle::doc_date()`"
package: "`r BiocStyle::pkg_ver('imcRtools')`"
author:
- name: Nils Eling
  affiliation: 
  - Department for Quantitative Biomedicine, University of Zurich
  - Institute for Molecular Health Sciences, ETH Zurich
  email: nils.eling@dqbm.uzh.ch
output:
    BiocStyle::html_document:
        toc_float: yes
bibliography: library.bib
abstract: |
    This R package supports the handling and analysis of imaging mass cytometry 
    and other highly multiplexed imaging data. The main functionality includes 
    reading in single-cell data after image segmentation and measurement, data 
    formatting to perform channel spillover correction and a number of spatial 
    analysis approaches. First, cell-cell interactions are detected via spatial 
    graph construction; these graphs can be visualized with cells representing 
    nodes and interactions representing edges. Furthermore, per cell, its direct 
    neighbours are summarized to allow spatial clustering. Per image/grouping 
    level, interactions between types of cells are counted, averaged and 
    compared against random permutations. In that way, types of cells that 
    interact more (attraction) or less (avoidance) frequently than expected by 
    chance are detected. 
vignette: |
    %\VignetteIndexEntry{"Tools for IMC data analysis"}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---

```{r, echo=FALSE, results="hide"}
knitr::opts_chunk$set(error=FALSE, warning=FALSE, message=FALSE, crop = NULL)
library(BiocStyle)
```

```{r library, echo=FALSE}
library(imcRtools)
```

# Introduction

This vignette gives an introduction to handling and analyzing imaging mass
cytometry (IMC) and other highly-multiplexed imaging data in R. The `imcRtools`
package relies on expression and morphological features extracted from
multi-channel images using corresponding segmentation masks. A description
of data types and segmentation approaches can be found below 
([data types](#dataTypes), [segmentation](#segmentation)). However, due to
shared data structures, the functionalities of the `imcRtools` package are
applicable to most highly multiplexed imaging modalities.

## Overview

The `imcRtools` package exports functions and example data to perform the 
following analyses:

1. Read in 
2.
3.
4. 

## Highly multiplexed imaging

### Imaging mass cytometry

### Data types {#dataTypes}

### Segmentation and feature extraction {#segmentation}

# Example data

The `imcRtools` package contains a number of example data generated by the
Hyperion imaging system for different purposes. The following section gives an
overview of these files.

## For spillover correction

To highlight the use of the `imcRtools` package for spillover correction, 
we provide four .txt files containing pixel intensities of four spotted metals.

These files are accessible via:

```{r access-spillover-files}
path <- system.file("extdata/spillover", package = "imcRtools")

list.files(path, recursive = TRUE)
```

## Raw data in form of .txt files

To highlight reading in raw data in form of .txt files, the `imcRtools` contains
3 sample acquisitions:

```{r access-txt-files}
txt_files <- list.files(system.file("extdata/mockData/raw", 
                                    package = "imcRtools"))
txt_files
```

## `ImcSegmentationPipeline` output data

IMC data preprocessing and segmentation can be performed using the 
[ImcSegmentationPipeline](https://github.com/BodenmillerGroup/ImcSegmentationPipeline).
It generates a number of `.csv` files containing object/cell-specific
and image-specific metadata. 

The `imcRtools` package exports the `read_cpout` function as convenient reader
for outpouts generated by the `ImcSegmentationPipeline`. For demonstration 
purposes, `imcRtools` contains the output of runnin the pipeline on a small
example dataset:

```{r imcsegmentationpipeline-data}
path <- system.file("extdata/mockData/cpout", package = "imcRtools")

list.files(path, recursive = TRUE)
```

## `steinbock` output data

The [steinbock](https://github.com/BodenmillerGroup/steinbock) pipeline can be used
to process, segment and extract features from IMC data. For more information,
please refer to the [documentation](https://bodenmillergroup.github.io/steinbock/).

To highlight the functionality of `imcRtools` to read in single-cell data generated
by `steinbock`, we provide a small toy dataset available at:

```{r steinbock-data}
path <- system.file("extdata/mockData/steinbock", package = "imcRtools")

list.files(path, recursive = TRUE)
```

# Read in IMC data

The `imcRtools` package supports reading in data generated by the [ImcSegmentationPipeline](https://github.com/BodenmillerGroup/ImcSegmentationPipeline) 
or [steinbock](https://github.com/BodenmillerGroup/steinbock) pipeline.

To read in the outpout data into a `r BiocStyle::Biocpkg("SpatialExperiment")` 
or `r BiocStyle::Biocpkg("SingleCellExperiment")`, the `imcRtools` package
exports the `read_cpout` function.

By default, the single-cell data is read into a `r BiocStyle::Biocpkg("SpatialExperiment")` 
object. Here, the extracted channel- and cell-specific intensities are stored in
the `counts(spe)` slot. All morphological features are stored in `colData(spe)`
and the spatial locations of the cells are stored in `spatialCoords(spe)`.
The interaction graph is stored in `colPair(spe, "neighbourhood")`.

Alternatively, the data can be read into a `r BiocStyle::Biocpkg("SingleCellExperiment")`
object. The only difference is the lack of `spatialCoords(sce)`. Here, the 
spatial coordinates are stored in `colData(spe)$Pos_X` and `colData(spe)$Pos_Y`.

## Read in CellProfiler output

The [ImcSegmentationPipeline](https://github.com/BodenmillerGroup/ImcSegmentationPipeline)
produces a number of output file. By default, all single-cell features are measured 
and exported. To select the features of interest, the `imcRtools` package provides
the `show_cpout_features` function. Here, the exported features can be interactively browsed:

```{r show_cpout_features}
path <- system.file("extdata/mockData/cpout", package = "imcRtools")

show_cpout_features(path)
```

By default, `read_cpout` will read in the mean intensity per channel and cell 
from "hot pixel" filtered image stacks specified via 
`intensities = "Intensity_MeanIntensity_FullStackFiltered"`:

```{r read_cpout}
cur_path <- system.file("extdata/mockData/cpout", package = "imcRtools")

# Read as SpatialExperiment
(spe <- read_cpout(cur_path))

# Read as SingleCellExperiment
(sce <- read_cpout(cur_path, return_as = "sce"))
```

## Read in steinbock output

Single-cell data and all associated metadata (e.g. spatial location, morphology
and interaction graphs) as produced by the
[steinbock](https://github.com/BodenmillerGroup/steinbock) pipeline can be read
in using the `read_steinbock` function:

```{r read_steinbock}
cur_path <- system.file("extdata/mockData/steinbock", package = "imcRtools")

# Read as SpatialExperiment
(spe <- read_steinbock(cur_path))

# Read as SingleCellExperiment
(sce <- read_steinbock(cur_path, return_as = "sce"))
```

For more information on the `read_steinbock` function, please refer to
`?read_steinbock`.

## Read raw .txt files into `Image` objects

For reading in and visualization of multi-channel images and segmentation masks,
please refer to the `r BiocStyle::Biocpkg("cytomapper")` package. The
`imcRtools` package however supports reading in raw .txt files generated by the
Hyperion imaging system into a `CytoImageList` object; a data container exported
by `cytomapper`.

The user needs to provide a path from which all .txt files will be read in:

```{r read-txt-1}
path <- system.file("extdata/mockData/raw", package = "imcRtools")

cur_CytoImageList <- readImagefromTXT(path)
cur_CytoImageList
```

# Spillover correction for IMC data

When acquiring IMC images, pixel intensities can be influenced by spillover 
from neighbouring channels. To correct for this, Chevrier _et al._ have 
developed a staining protocol to acquire individually spotted metal isotopes
[@Chevrier].
Based on these measurements, spillover into neighbouring channels can be
quantified and pixel intensities can be deconvolved into true and spillover
signal. 

The `imcRtools` package provides helper functions that facilitate the correction
of spillover for IMC data. For a full tutorial, please refer to the [IMC data analysis book](https://bodenmillergroup.github.io/IMCDataAnalysis/spillover-correction.html#ref-Chevrier2017).

## Read in the single-spot acquisition

In the first step, the pixel intensities of individually spotted metals need to 
be read into a `SingleCellExperiment` container for downstream use with the
`CATALYST` package. For this, the `readSCEfromTXT` function can be used:

```{r read-single-metals}
path <- system.file("extdata/spillover", package = "imcRtools")
sce <- readSCEfromTXT(path) 
sce
```

Here, the example metal spot files are read in. The spot information are stored
in the `colData(sce)` slot and channel information are stored in `rowData(sce)`.
Each column represents a single pixel.

## Quality control on single-spot acquisitions

In the next step, it is crucial to identify potential mislabeled spots or spots 
with low pixel intensities, the `imcRtools` package exports the `plotSpotHeatmap`
function, which visualizes the aggregated (default `median`) pixel intensities
per spot and per metal:

```{r plotSpotHeatmap, fig.width=5, fig.height=5}
plotSpotHeatmap(sce)
```

Here, high median pixel intensities can be observed in each spot an their 
corresponding channels (visualized on the `log10` scale).
To quickly identify spot/channel combinations with low signal, the `threshold`
parameter can be set:

```{r plotSpotHeatmap-2, fig.width=5, fig.height=5}
plotSpotHeatmap(sce, log = FALSE, threshold = 200)
```

## Consecutive pixel binning

If pixel intensities are low, spillover estimation might not be robust. 
Therefore, the `binAcrossPixels` function can be used to sum consecutive pixels
and enhance the acquired signal. This step is optional for spillover estimation.

```{r pixel-binning, fig.width=5, fig.height=5 }
sce2 <- binAcrossPixels(sce, bin_size = 5)

plotSpotHeatmap(sce2, log = FALSE, threshold = 200)
```

## Pixel filtering

Prior to spillover estimation, the `r BiocStyle::Biocpkg("CATALYST")` package
provides the `assignPrelim`, `estCutoffs` and `applyCutoffs` functions to
estimate the spotted mass for each pixel based on their channel intensities.
For more information on the spillover estimation and correction, please refer
to the [CATALYST vignette]().

This estimation can be used to identify pixels that cannot be easily assigned
to their spotted mass, potentially indicating pixels with weak signal. To remove
these pixels, the `filterPixels` function can be used. This function further
removes pixels assigned to masses, which only contain very few pixels.

```{r assign-pixels}
library(CATALYST)

bc_key <- as.numeric(unique(sce$sample_mass))
assay(sce, "exprs") <- asinh(counts(sce)/5)
sce <- assignPrelim(sce, bc_key = bc_key)
sce <- estCutoffs(sce)
sce <- applyCutoffs(sce)

# Filter out mislabelled pixels
sce <- filterPixels(sce)

table(sce$bc_id, sce$sample_mass)
```

## Estimating the spillover matrix

Finally, the pre-processed `SiingleCellExperiment` object can be used to 
generate the spillover matrix using the `CATALYST::computeSpillmat` function:

```{r estimate-spillover}
sce <- computeSpillmat(sce)
metadata(sce)$spillover_matrix
```

# Spatial analysis

The following section will highlight functions for spatial analysis of the data.

## Constructing graphs

When following the `ImcSegmentationPipeline` or `steinbock`, the generated 
graphs are automatically stored in the `colPair(spe, "neighbourhood")` slot.
Alternatively, the `buildSpatialGraph` function in the `imcRtools` package
constructs interaction graphs using either (i) cell-centroid expansion,
(ii) k-nearest neighbor search or (iii) delaunay triangulation.

```{r buildSpatialGraph, message=FALSE}
library(cytomapper)
data("pancreasSCE")

pancreasSCE <- buildSpatialGraph(pancreasSCE, img_id = "ImageNb",
                                 type = "expansion",
                                 threshold = 20)
pancreasSCE <- buildSpatialGraph(pancreasSCE, img_id = "ImageNb",
                                 type = "knn",
                                 k = 5)
pancreasSCE <- buildSpatialGraph(pancreasSCE, img_id = "ImageNb",
                                 type = "delaunay")

colPairNames(pancreasSCE)
```

When setting `type = "knn"`, by default a directional graph will be build.
Setting `directed = FALSE` will create bi-directional edges for each pair of 
cells that are connected by at least one edge in the directed setting.

## Graph/cell visualization

The cells' locations and constructed graphs can be visualized using the 
`plotSpatial` function. Here, cells are referred to as "nodes" and cell-cell
interactions are referred to as "edges". All visual attributes of the nodes
and edges can be set. Either by specifying a variable in `colData(spe)`, a
marker name or a single entry using the `*_fix` parameters.

```{r plotSpatial}
library(ggplot2)
library(ggraph)

plotSpatial(pancreasSCE,
            img_id = "ImageNb",
            node_color_by = "CellType",
            node_shape_by = "ImageNb",
            node_size_by = "Area",
            draw_edges = TRUE,
            colPairName = "knn_interaction_graph",
            directed = FALSE)

# Colored by expression and with arrows
plotSpatial(pancreasSCE,
            img_id = "ImageNb",
            node_color_by = "PIN",
            assay_type = "exprs",
            node_size_fix = 3,
            edge_width_fix = 0.2,
            draw_edges = TRUE,
            colPairName = "knn_interaction_graph",
            directed = TRUE,
            arrow = grid::arrow(length = grid::unit(0.1, "inch")),
            end_cap = ggraph::circle(0.05, "cm"))

# Subsetting the SingleCellExperiment
plotSpatial(pancreasSCE[,pancreasSCE$Pattern],
            img_id = "ImageNb",
            node_color_by = "CellType",
            node_size_fix = 1,
            draw_edges = TRUE,
            colPairName = "knn_interaction_graph",
            directed = TRUE,
            scales = "fixed") 
```

The returned object can be further modified using the `ggplot2` logic. This
includes chaning the node color, shape and size using `scale_color_*`,
`scale_shape_*` and `scale_size_*`. Edge attributes can be altered using the
`scale_edge_*` exported by `ggraph`,

## Neighborhood aggregation

The `aggregatedNeighbors` function can be used to aggregate features of all
neighboring cells for each individual cell. This function operates in two 
settings. 1. `metadata`: when aggregating by cell-specific metadata, the 
function computes the relative frequencies of all entries to 
`colData(sce)[[count_by]]` within the direct neighborhood of each cell. 
2. `expression`: the expression counts stored in `assay_type` are aggregated
using the specified `statistic` (defaults to `mean`). 

Each cell's neighborhood is defined as endpoints of edges stored in 
`colPair(sce, colPairName)`.

```{r aggregateNeigbors}
pancreasSCE <- aggregateNeighbors(pancreasSCE,
                                  colPairName = "knn_interaction_graph",
                                  aggregate_by = "metadata",
                                  count_by = "CellType")
head(pancreasSCE$aggregatedNeighbors)

pancreasSCE <- aggregateNeighbors(pancreasSCE,
                                  colPairName = "knn_interaction_graph",
                                  aggregate_by = "expression",
                                  assay_type =  "exprs")
head(pancreasSCE$mean_aggregatedExpression)
```

The returned entries can now be used for clustering to group cells based on their
environment (either by aggregated categorial features or expression).

```{r aggregateNeigbors-clustering}
cur_cluster <- kmeans(pancreasSCE$aggregatedNeighbors, centers = 3)
pancreasSCE$clustered_neighbors <- factor(cur_cluster$cluster)

plotSpatial(pancreasSCE,
            img_id = "ImageNb",
            node_color_by = "CellType",
            node_size_fix = 4,
            edge_width_fix = 2,
            edge_color_by = "clustered_neighbors",
            draw_edges = TRUE,
            colPairName = "knn_interaction_graph",
            directed = FALSE,
            nodes_first = FALSE) +
    scale_color_brewer(palette = "Set2") +
    scale_edge_color_brewer(palette = "Set1")
```

To exclude cells that are close to the image border, the `imcRtools` package
exports the `findBorderCells` function.

```{r findBorderCells}
pancreasSCE <- findBorderCells(pancreasSCE, 
                               img_id = "ImageNb", 
                               border_dist = 10)

plotSpatial(pancreasSCE[,!pancreasSCE$border_cells],
            img_id = "ImageNb",
            node_color_by = "CellType",
            node_size_fix = 4,
            edge_width_fix = 2,
            edge_color_by = "clustered_neighbors",
            draw_edges = TRUE,
            colPairName = "knn_interaction_graph",
            directed = FALSE,
            nodes_first = FALSE) +
    scale_color_brewer(palette = "Set2") +
    scale_edge_color_brewer(palette = "Set1")
```

## Neighborhood permutation testing

The following section describes how to observe and test the average number of
interactions between cell labels (e.g. cell-types) within grouping levels (e.g.
images). For full descriptions of the testing approaches, please refer to
[Shapiro et al., Nature
Methods](https://www.nature.com/articles/nmeth.4391)[@Shapiro2017] and [Schulz
et al., Cell
Systems](https://www.sciencedirect.com/science/article/pii/S2405471217305434)
[@Schulz2018]

The `imcRtools` package exports the `countInteractions` and
`testInteractions` function, which summarize all cell-cell interactions per
grouping level (e.g. image). As a result, a table is returned where each row
represents one of all possible cell-type/cell-type interactions among all
grouping levels. Missing entries or `NA`s indicate missing cell-type labels for
this grouping level. The next section gives details on how interactions are 
summarized.

### Summarizing interactions

The `countInteractions` function counts the number of edges (interactions)
between each set of unique cell labels per grouping level.
Simplified, it counts for each cell of type A the number of neighbors of type B.
This count is averaged within each unique grouping level (e.g. image) 
in three different ways:

1. `method = "classic"`: The count is divided by the total number of 
cells of type A. The final count can be interpreted as "How many neighbors 
of type B does a cell of type A have on average?" 
  
2. `method = "histocat"`: The count is divided by the number of cells
of type A that have at least one neighbor of type B. The final count can be 
interpreted as "How many many neighbors of type B has a cell of type A on 
average, given it has at least one neighbor of type B?"
 
3. `method = "patch"`: For each cell, the count is binarized to 0 
(less than `patch_size` neighbors of type B) or 1 (more or equal to 
`patch_size` neighbors of type B). The binarized counts are averaged 
across all cells of type A. The final count can be interpreted as "What 
fraction of cells of type A have at least a given number of neighbors of 
type B?"

The `countInteractions` returns a `DataFrame` containing the summarized
counts (`ct`) for all combinations of `from_label`, `to_label` and `group_by`.

```{r countInteractions}
out <- countInteractions(pancreasSCE,
                         group_by = "ImageNb",
                         label = "CellType",
                         method = "classic",
                         colPairName = "knn_interaction_graph")
out
```

### Testing for significance

In the next instance, one can test if the obtained count is larger or smaller
compared to what is expected from a random distribution of cell labels. For
this, the `testInteractions` function permutes the cell labels `iter` times
and counts interactions as described above. This approach generates a
distribution of the interaction count under a random distribution of cell
labels. The observed interaction count is compared against this Null
distribution to derive empirical p-values:
 
`p_gt`: fraction of perturbations equal or greater than the observed count
 
`p_lt`: fraction of perturbations equal or less than the observed count
 
Based on these empirical p-values, the `interaction` score (attraction
or avoidance), overall `p` value and significance by comparison to
`p_treshold` (`sig` and `sigval`) are derived. All results are returned in form
of a `DataFrame`.

```{r testInteractions}
out <- testInteractions(pancreasSCE,
                        group_by = "ImageNb",
                        label = "CellType",
                        method = "classic",
                        colPairName = "knn_interaction_graph")
out
```

## Patch detection

# Acknowledgements

# Contributions

# Session info {.unnumbered}

```{r sessionInfo, echo=FALSE}
sessionInfo()
```

# References
